# NetHack 3.6	Makefile.BC	$NHDT-Date: 1432512791 2015/05/25 00:13:11 $  $NHDT-Branch: master $:$NHDT-Revision: 1.17 $
# Copyright (c) Yitzhak Sapir, 1999-2006.
# NetHack may be freely distributed.  See license for details.
#

# PC NetHack 3.6 Makefile for Borland C++ 3.1 and 4.5.
#
# Nota Bene:	Before you get to here you should have already read
# 		the Install.dos file located in the sys/msdos directory.
#		Additionally, you should run this makefile with the -N
#		Microsoft Compatibility option.
#
# This Makefile is for use with Borland C++ version 3.1 and 4.5, but might
# also work with more up to date versions.
#
# This Makefile is specific to Borland's MAKE which is supplied with the
# compiler.  It supports only one overlay management facility - VROOMM.
# (This Makefile won't work with make45l or NDMAKE)
#
# NOTE: This Makefile has not been tested with NetHack 3.6.x

#
# Game Installation Variables.
# NOTE: Make sure GAMEDIR exists before nmake is started.
#

GAME	= NetHack
GAMEDIR = ..\binary

#
#
# Directories
#

DAT	= ..\dat
DOC	= ..\doc
INCL	= ..\include
SRC	= ..\src
OBJ	= o
MSYS	= ..\sys\msdos
SYS	= ..\sys\share
UTIL	= ..\util
WTTY	= ..\win\tty
WSHR	= ..\win\share


#
# Compiler File Info.
# ($(MAKE) macro is often predefined, so we use $(MAKEBIN) instead.)
#

CC	 = bcc		# Compiler
LINK	 = tlink	# Linker
ASM	 = tasm		# Assembler (not currently needed for BC)
MAKEBIN  = make
UUDECODE = uudecode	# Unix style uudecoder

#BCTOP	 = c:\borlandc	# main Borland C++ directory
BCTOP	 = c:\bc31

#
# Yacc/Lex ... if you got 'em.
#
# If you have yacc and lex programs (or work-alike such as bison
# and flex), comment out the upper two lines below, and uncomment
# the lower two.
#
# On Borland C++, the newest versions of flex and bison provide
# problems when run from MAKE.
#

DO_YACC = YACC_MSG
DO_LEX  = LEX_MSG
#DO_YACC  = YACC_ACT
#DO_LEX   = LEX_ACT

#
# - Specify your yacc and lex programs (or work-alikes for each) here.
#

YACC	= bison -y
#YACC   = yacc
#YACC   = byacc

LEX     = flex
#LEX    = lex

#
# - Specify your flex skeleton file (if needed).
#
FLEXSKEL =
#FLEXSKEL = -Sc:\tools16\flex.ske

#
# - Your yacc (or work-alike) output files
#
YTABC	= y_tab.c
YTABH	= y_tab.h
#YTABC  = ytab.c
#YTABH  = ytab.h

#
# - Your lex (or work-alike) output files
#
LEXYYC	= lexyy.c
#LEXYYC	= lex.yy.c

#
# Optional high-quality BSD random number generation routines
# (see pcconf.h). Set to nothing if not used.
#

RANDOM	= $(OBJ)\random.o
#RANDOM	=

#
# If TERMLIB is #defined in the source (in include\pcconf.h),
# comment out the upper line and uncomment the lower.  Make sure
# that TERMLIB contains the full pathname to the termcap library.

TERMLIB =
#TERMLIB = $(SYS)\termcap.lib

#
# MEMORY USAGE AND OVERLAYING
#
# Overlay Schema 1
#
#   - Minimal extended memory available, lots of 640K base RAM free
#     Minimize overlay turns. Requires that a minimum of
#     607K RAM be free as follows:
#     462K  Executable load requirement
#     115K  for malloc() calls
#      30K  Overlay buffer
#     607K  Total memory requirement
#
# Overlay Schema 2
#
#   - Favor small load size, requires extended memory for bearable performance.
#     If you have very little base 640K RAM available, but lots of extended
#     memory for caching overlays, you might try this. (eg. A machine with
#     lots of TSR's or network drivers).  Do not try to set SCHEMA = 2
#     without a disk cache and extended memory.
#     381K  Executable load requirement
#     115K  for malloc() calls
#      30K  Overlay buffer
#     526K  Total memory requirement
#
# On Borland C++, you have to make a full rebuild of all object modules each
# time you change schemas.
#

SCHEMA	= 2

#
# OPTIONAL TILE SUPPORT.
#
#	This release of NetHack allows you to build a version of NetHack
#	that will draw 16x16 color tiles on the display to represent
#	NetHack maps, objects, monsters, etc. on machines with appropriate
#	display hardware.  Currently the only supported video hardware is
#	VGA.
#
#	Note:  You can build NetHack with tile support and then choose
#	whether to use it or not at runtime via the defaults.nh file option
#	"video".
#

TILESUPPORT = Y

#
#  C COMPILER AND LINKER SETTINGS
#
#   For debugging ability, comment out the upper three
#   macros and uncomment the lower three.  You can also
#   uncomment only either LDFLAGSU or LDFLAGSN if you
#   want to include debug information only in the utilities
#   or only in the game file.

#   On Borland C++, you cannot include debug information for
#   all the object modules because the linker cannot handle
#   it.

#CDFLAGS  =
LDFLAGSN  =
#LDFLAGSU =

CDFLAGS	  = -v -vi		# use debug info (compiler)
#LDFLAGSN = /v			# use debug info (linker - game)
LDFLAGSU  = /v			# use debug info (linker - utilities)

#
# - Don't warn about unreachable code because flex generates a whole bunch
#   of unreachable code warnings, which stops the compile process.
#

CW = -w-rch

#
#   Select whether to use pre-compiled headers or not.
#   Set PRECOMPHEAD to Y to use pre-compiled headers, set it to anything
#   else and pre-compiled headers will not be used.
#   (Pre-compiled headers speed up compiles, but require a bit more
#   disk space during the build.  The pre-compiled headers can be deleted
#   afterwards via DEL *.PCH if desired).
#

PRECOMPHEAD = N

#
#   C Compiler Flags
#

CFLAGS = -c

#  Uncomment the line below if you want to store all the level files,
#  help files, etc. in a single library file (recommended).

USE_DLB = Y

#
########################################################################
########################################################################
#
#  Nothing below here should have to be changed.
#
########################################################################
########################################################################
#
#  Warning:
#
#  Changing anything below here means that you should be *very*
#  familiar with your compiler's workings, *very* knowledgeable
#  about the overlay structure and mechanics of NetHack, and *very*
#  confident in your understanding of Makefiles and Make utilities.
#
########################################################################
#
# Default Make Procedure
#

default: $(GAME)

#
########################################################################
# Tile preparation
#

! IF ("$(TILESUPPORT)"=="Y")

TILEGAME  = $(OBJ)\tile.o	$(OBJ)\pctiles.0	$(OBJ)\pctiles.b

#
#   -  VGA Tile Support, uncomment these three lines.
#

TILEVGA    = $(OBJ)\vidvga.0 $(OBJ)\vidvga.1 $(OBJ)\vidvga.2 $(OBJ)\vidvga.b
PLANAR_TIB = NetHack1.tib
OVERVIEW_TIB = NetHacko.tib

#
# Leave this line uncommented and unchanged.
TILEUTIL  =  $(TILEGAME) $(TILEVGA) $(UTIL)\tile2bin.exe $(UTIL)\til2bin2.exe \
		 $(PLANAR_TIB) $(OVERVIEW_TIB)

! ENDIF

! IF ("$(USE_DLB)"=="Y")
DLB = nhdat
! ELSE
DLB =
! ENDIF

#
#############################################################################
#
# General Overlay Schema Settings
#

OVLINIT =$(OBJ)\ovlinit.o


#
#############################################################################
#
# C Compiler and Linker Setup Options
# (To Maintainer; modify only if absolutely necessary)
#

BCINCL	 = $(BCTOP)\include	# include directory for main BC headers
BCLIB	 = $(BCTOP)\lib		# library directory for main BC libraries
BCCFG	 = nethack.cfg		# name of the nethack configuration file
VROOMMCFG= vroomm.cfg		# name of file with code segment information

#
# Model
#

MODEL	 = h

#
# - Optional C library specifier for those with non-standard
#   libraries or a multiple-target library setup.
#

CLIB    =

#
# Borland C++ libraries
#

BCOVL	= $(BCLIB)\OVERLAY
BCMDL	= $(BCLIB)\C$(MODEL)

#
# Compiler Options
#

CNOLNK	= -c			# just generate .OBJ
CPCHUSE	= -Hu			# use precompiled headers
CPCHGEN	= -H			# generate precompiled headers
CPCHNAM	= -H=			# set the name of the precompiled header file
CPCHEXT = .PCH			# precompiled header extension
CDEFINE	= -D			# define a macro
CSTKSZ	= -DSTKSIZ=		# set stack size
CCSNAM	= -zC			# set the code segment name
COBJNAM	= -o			# name the .OBJ file

#
# Linker Options
#

LWCASE	= /c			# treat case as significant
LMAP	= /m			# create map file
LINIT	= $(BCLIB)\C0$(MODEL)	# initialization object file
LOVL	= /oOVLY		# overlay all needed segments

#
# Stack Sizes
#

STKSUTL	= 4096			# Utilities Stack Size
STKSNRM = 5120			# Normal Stack Size

CUSTACK	= $(CSTKSZ)$(STKSUTL)	# Utilities Stack Set for Compiler
CNSTACK	= $(CSTKSZ)$(STKSNRM)	# Normal Stack Set for Compiler


#
########################################################################
# DLB preparation
#

! IF ("$(USE_DLB)"=="Y")
DLBFLG = $(CDEFINE)DLB
! ELSE
DLBFLG =
! ENDIF

#
########################################################################
# tile preparation
#

! IF ("$(TILESUPPORT)"=="Y")
TILFLG = $(CDEFINE)TILES_IN_GLYPHMAP
! ELSE
TILFLG =
! ENDIF

#############################################################################
#
# Overlay switches
#

COVL0	= $(CDEFINE)OVL0
COVL1	= $(CDEFINE)OVL1
COVL2	= $(CDEFINE)OVL2
COVL3	= $(CDEFINE)OVL3
COVLB	= $(CDEFINE)OVLB

#
# Flags
#

FLAGOPT = $(DLBFLG) $(TILFLG)

#
# Precompiled Header Section
#

#common options (placed in $(BCCFG))
CFLGTOT = $(CDFLAGS) $(CFLAGS) $(FLAGOPT) $(CW)
#util builds
CFLAGSU	= $(CUSTACK) +$(VROOMMCFG)
#normal build, no PCH
CFLAGSN = $(CNSTACK) +$(VROOMMCFG)
#no optimizations
CFLAGNO = $(CNOOPT) $(CFLAGSN)

! IF ("$(PRECOMPHEAD)"!="Y")

CFLAGCO = $(COVLO)
CFLAGUO = $(COVLO)
CFLAGC0 = $(COVL0)
CFLAGU0 = $(COVL0)
CFLAGC1 = $(COVL1)
CFLAGU1 = $(COVL1)
CFLAGC2 = $(COVL2)
CFLAGU2 = $(COVL2)
CFLAGC3 = $(COVL3)
CFLAGU3 = $(COVL3)
CFLAGCB = $(COVLB)
CFLAGUB = $(COVLB)
PCHO =
PCH0 =
PCH1 =
PCH2 =
PCH3 =
PCHB =

precomp.msg:
	@echo Not using precompiled headers...

! ELSE

# .o files
CFLAGUO	= $(CPCHUSE) $(CPCHNAM)PHO$(CPCHEXT) $(COVLO)
CFLAGCO	= $(CPCHGEN) $(CPCHNAM)PHO$(CPCHEXT) $(COVLO)
PCHO = PHO$(CPCHEXT)
# .0 files
CFLAGU0	= $(CPCHUSE) $(CPCHNAM)PH0$(CPCHEXT) $(COVL0)
CFLAGC0	= $(CPCHGEN) $(CPCHNAM)PH0$(CPCHEXT) $(COVL0)
PCH0 = PH0$(CPCHEXT)
# .1 files
CFLAGU1	= $(CPCHUSE) $(CPCHNAM)PH1$(CPCHEXT) $(COVL1)
CFLAGC1	= $(CPCHGEN) $(CPCHNAM)PH1$(CPCHEXT) $(COVL1)
PCH1 = PH1$(CPCHEXT)
# .2 files
CFLAGU2	= $(CPCHUSE) $(CPCHNAM)PH2$(CPCHEXT) $(COVL2)
CFLAGC2	= $(CPCHGEN) $(CPCHNAM)PH2$(CPCHEXT) $(COVL2)
PCH2 = PH2$(CPCHEXT)
# .3 files
CFLAGU3	= $(CPCHUSE) $(CPCHNAM)PH3$(CPCHEXT) $(COVL3)
CFLAGC3	= $(CPCHGEN) $(CPCHNAM)PH3$(CPCHEXT) $(COVL3)
PCH3 = PH3$(CPCHEXT)
# .B files
CFLAGUB	= $(CPCHUSE) $(CPCHNAM)PHB$(CPCHEXT) $(COVLB)
CFLAGCB	= $(CPCHGEN) $(CPCHNAM)PHB$(CPCHEXT) $(COVLB)
PCHB = PHB$(CPCHEXT)

precomp.msg:
	@echo Using precompiled headers...

! ENDIF


FLAGCO  = $(CNSTACK) +$(VROOMMCFG)
FLAGUO  = $(CNSTACK) +$(VROOMMCFG)
FLAGC0  = $(CNSTACK) +$(VROOMMCFG)
FLAGU0  = $(CNSTACK) +$(VROOMMCFG)
FLAGC1  = $(CNSTACK) +$(VROOMMCFG)
FLAGU1  = $(CNSTACK) +$(VROOMMCFG)
FLAGC2  = $(CNSTACK) +$(VROOMMCFG)
FLAGU2  = $(CNSTACK) +$(VROOMMCFG)
FLAGC3  = $(CNSTACK) +$(VROOMMCFG)
FLAGU3  = $(CNSTACK) +$(VROOMMCFG)
FLAGCB  = $(CNSTACK) +$(VROOMMCFG)
FLAGUB  = $(CNSTACK) +$(VROOMMCFG)

# End of Pre-compiled header section
#===========================================================================

#
# Basic Borland C++ option line
#
BCOPTS1 = -Y -O -Z -Oe -Ob -Os -Ff -I$(BCINCL);$(INCL) -m$(MODEL)
BCOPTS2 = $(CDEFINE)__IO_H $(CFLGTOT) -DSTRNCMPI

#
# Linker options for building various things.
#

LFLAGSU	= $(LDFLAGSU) $(LUSTACK) $(LINIT)
LFLAGSN	= $(LDFLAGSN) $(LNSTACK) $(LWCASE) $(LMAXSEG) $(INTOVL) $(LMAXALL) \
	  $(LINFO) $(LINIT) $(LOVL)

#
# Make Roolz dude.
# Due to the inadequacy of some makes these must accord with a
# topological sort of the generated-from relation... output on
# the left, input on the right. Trust me.
#

.SUFFIXES:  .exe .0 .1 .2 .3 .B .o .til .uu .c .y .l

#
# Rules for files in src
#


.c{$(OBJ)}.o:
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUO) >> $(VROOMMCFG)
	$(CC) $(FLAGUO) $(COBJNAM)$@ $<

{$(SRC)}.c{$(OBJ)}.o:
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUO) >> $(VROOMMCFG)
	$(CC) $(FLAGUO) $(COBJNAM)$@ $<

{$(SRC)}.c{$(OBJ)}.0:
	@type schema$(SCHEMA).bc | find "$(@B)_0" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU0) >> $(VROOMMCFG)
	$(CC) $(FLAGU0) $(COBJNAM)$@ $<

{$(SRC)}.c{$(OBJ)}.1:
	@type schema$(SCHEMA).bc | find "$(@B)_1" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU1) >> $(VROOMMCFG)
	$(CC) $(FLAGU1) $(COBJNAM)$@ $<

{$(SRC)}.c{$(OBJ)}.2:
	@type schema$(SCHEMA).bc | find "$(@B)_2" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU2) >> $(VROOMMCFG)
	$(CC) $(FLAGU2) $(COBJNAM)$@ $<

{$(SRC)}.c{$(OBJ)}.3:
	@type schema$(SCHEMA).bc | find "$(@B)_3" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU3) >> $(VROOMMCFG)
	$(CC) $(FLAGU3) $(COBJNAM)$@ $<

{$(SRC)}.c{$(OBJ)}.B:
	@type schema$(SCHEMA).bc | find "$(@B)_b" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUB) >> $(VROOMMCFG)
	$(CC) $(FLAGUB) $(COBJNAM)$@ $<

#
# Rules for files in sys\share
#

{$(SYS)}.c{$(OBJ)}.o:
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUO) >> $(VROOMMCFG)
	$(CC) $(FLAGUO) $(COBJNAM)$@ $<

{$(SYS)}.c{$(OBJ)}.0:
	@type schema$(SCHEMA).bc | find "$(@B)_0" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU0) >> $(VROOMMCFG)
	$(CC) $(FLAGU0) $(COBJNAM)$@ $<

{$(SYS)}.c{$(OBJ)}.1:
	@type schema$(SCHEMA).bc | find "$(@B)_1" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU1) >> $(VROOMMCFG)
	$(CC) $(FLAGU1) $(COBJNAM)$@ $<

{$(SYS)}.c{$(OBJ)}.2:
	@type schema$(SCHEMA).bc | find "$(@B)_2" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU2) >> $(VROOMMCFG)
	$(CC) $(FLAGU2) $(COBJNAM)$@ $<

{$(SYS)}.c{$(OBJ)}.3:
	@type schema$(SCHEMA).bc | find "$(@B)_3" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU3) >> $(VROOMMCFG)
	$(CC) $(FLAGU3) $(COBJNAM)$@ $<

{$(SYS)}.c{$(OBJ)}.B:
	@type schema$(SCHEMA).bc | find "$(@B)_b" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUB) >> $(VROOMMCFG)
	$(CC) $(FLAGUB) $(COBJNAM)$@ $<

#
# Rules for files in sys\msdos
#

{$(MSYS)}.c{$(OBJ)}.o:
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUO) >> $(VROOMMCFG)
	$(CC) $(FLAGUO) $(COBJNAM)$@ $<

{$(MSYS)}.c{$(OBJ)}.0:
	@type schema$(SCHEMA).bc | find "$(@B)_0" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU0) >> $(VROOMMCFG)
	$(CC) $(FLAGU0) $(COBJNAM)$@ $<

{$(MSYS)}.c{$(OBJ)}.1:
	@type schema$(SCHEMA).bc | find "$(@B)_1" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU1) >> $(VROOMMCFG)
	$(CC) $(FLAGU1) $(COBJNAM)$@ $<

{$(MSYS)}.c{$(OBJ)}.2:
	@type schema$(SCHEMA).bc | find "$(@B)_2" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU2) >> $(VROOMMCFG)
	$(CC) $(FLAGU2) $(COBJNAM)$@ $<

{$(MSYS)}.c{$(OBJ)}.3:
	@type schema$(SCHEMA).bc | find "$(@B)_3" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU3) >> $(VROOMMCFG)
	$(CC) $(FLAGU3) $(COBJNAM)$@ $<

{$(MSYS)}.c{$(OBJ)}.B:
	@type schema$(SCHEMA).bc | find "$(@B)_b" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUB) >> $(VROOMMCFG)
	$(CC) $(FLAGUB) $(COBJNAM)$@ $<

{$(MSYS)}.h{$(INCL)}.h:
	@copy $< $@

#
# Rules for files in util
#

{$(UTIL)}.c{$(OBJ)}.o:
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSU) (COBJNAM)$@ $<

#
# Rules for files in win\share
#

{$(WSHR)}.c.o:
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUO) >> $(VROOMMCFG)
	@$(CC) $(FLAGUO) $(COBJNAM)$@ $<

{$(WSHR)}.c{$(OBJ)}.o:
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUO) >> $(VROOMMCFG)
	@$(CC) $(FLAGUO) $(COBJNAM)$@ $<

{$(WSHR)}.h{$(INCL)}.h:
	@copy $< $@

{$(WSHR)}.txt{$(DAT)}.txt:
	@copy $< $@

#
# Rules for files in win\tty
#

{$(WTTY)}.c{$(OBJ)}.o:
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUO) >> $(VROOMMCFG)
	$(CC) $(FLAGUO) $(COBJNAM)$@ $<

{$(WTTY)}.c{$(OBJ)}.0:
	@type schema$(SCHEMA).bc | find "$(@B)_0" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU0) >> $(VROOMMCFG)
	$(CC) $(FLAGU0) $(COBJNAM)$@ $<

{$(WTTY)}.c{$(OBJ)}.1:
	@type schema$(SCHEMA).bc | find "$(@B)_1" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU1) >> $(VROOMMCFG)
	$(CC) $(FLAGU1) $(COBJNAM)$@ $<

{$(WTTY)}.c{$(OBJ)}.2:
	@type schema$(SCHEMA).bc | find "$(@B)_2" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU2) >> $(VROOMMCFG)
	$(CC) $(FLAGU2) $(COBJNAM)$@ $<

{$(WTTY)}.c{$(OBJ)}.3:
	@type schema$(SCHEMA).bc | find "$(@B)_3" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU3) >> $(VROOMMCFG)
	$(CC) $(FLAGU3) $(COBJNAM)$@ $<

{$(WTTY)}.c{$(OBJ)}.B:
	@type schema$(SCHEMA).bc | find "$(@B)_b" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUB) >> $(VROOMMCFG)
	$(CC) $(FLAGUB) $(COBJNAM)$@ $<

#
# NETHACK OBJECTS
#
# This section creates shorthand macros for many objects
# referenced later on in the Makefile.
#

#
# Shorten up the location for some files
#

O  = $(OBJ)\				# comment so \ isn't last char

U  = $(UTIL)\				# comment so \ isn't last char

#
# Utility Objects.
#

MAKESRC        = $(U)makedefs.c

MAKEOBJS       = $(O)makedefs.o	$(O)monst.o	$(O)objects.o

RECOVOBJS      = $(O)recover.o

GIFREADERS	=$(O)gifread.o $(O)alloc.o $(O)panic.o 

TEXT_IO	=$(O)tiletext.o $(O)tiletxt.o $(O)drawing.o \
		$(O)decl.o $(O)monst.o $(O)objects.o $(O)stubvid.o 

PPMWRITERS     = $(O)ppmwrite.o	$(O)alloc.o	$(O)panic.o

GIFREAD2	=$(O)gifread2.o $(O)alloc.o $(O)panic.o 

TEXT_IO2	=$(O)tiletex2.o $(O)tiletxt2.o $(O)drawing.o \
		$(O)decl.o $(O)monst.o $(O)objects.o $(O)stubvid.o 

PPMWRIT2       = $(O)ppmwrit2.o $(O)alloc.o	$(O)panic.o

TILEFILES      = $(WSHR)\monsters.txt $(WSHR)\objects.txt $(WSHR)\other.txt

TILEFILES2     = $(WSHR)\monthin.txt $(WSHR)\objthin.txt $(WSHR)\oththin.txt

DLBOBJS        = $(O)dlb_main.o $(O)dlb.o $(O)alloc.o $(O)panic.o

#
#  Object files for the game itself.
#

OBJ01 =	$(O)alloc.o	$(RANDOM)	$(O)decl.o     	$(O)objects.o	\
	$(O)muse.o	$(O)display.o	$(O)vision.o	$(O)mapglyph.o  \
	$(O)rect.o	$(O)monst.o	$(O)wintty.o	\
	$(O)files.o	$(O)sys.o	$(O)minion.o	\
	$(O)worm.o	$(O)detect.o 	$(O)exper.o	$(O)mplayer.o	\
	$(O)uhitm.o	$(O)pager.o 	$(O)windows.o	$(O)quest.o	\
	$(O)questpgr.o 	$(O)write.o	$(O)drawing.o	$(O)dokick.o	\
	$(O)dothrow.o 	$(O)pickup.o	$(O)pray.o	$(O)spell.o 	\
	$(O)ball.o	$(O)wield.o	$(O)worn.o	$(O)fountain.o	\
	$(O)music.o	$(O)rumors.o	$(O)dlb.o	$(O)sit.o 	\
	$(O)bones.o	$(O)mklev.o	$(O)save.o	$(O)restore.o 	\
	$(O)mkmaze.o	$(O)mkmap.o	$(O)end.o	$(O)o_init.o	\
	$(O)options.o	$(O)rip.o       $(O)teleport.o	\
	$(O)topten.o	$(O)tty.o	$(O)u_init.o	$(O)extralev.o 	\
	$(O)sp_lev.o	$(O)dig.o	$(O)pckeys.o	$(O)role.o	\
	$(O)steed.o	$(O)region.o

OVL0 =	$(O)allmain.0	$(O)apply.0	$(O)artifact.0	$(O)attrib.0  \
	$(O)botl.0	$(O)cmd.0	$(O)dbridge.0	$(O)do.0      \
	$(O)do_name.0	$(O)do_wear.0	$(O)dogmove.0	$(O)dungeon.0 \
	$(O)eat.0	$(O)engrave.0	$(O)hacklib.0	$(O)invent.0  \
	$(O)lock.0	$(O)pcmain.0	$(O)mail.0	$(O)makemon.0 \
	$(O)mcastu.0	$(O)mhitm.0	$(O)mhitu.0	$(O)mkobj.0   \
	$(O)mkroom.0	$(O)mon.0	$(O)mondata.0	$(O)monmove.0 \
	$(O)mthrowu.0	$(O)objnam.0	$(O)polyself.0	$(O)priest.0  \
	$(O)rnd.0	$(O)shknam.0	$(O)sounds.0	$(O)steal.0   \
	$(O)timeout.0	$(O)track.0	$(O)trap.0	$(O)vault.0   \
	$(O)weapon.0	$(O)were.0	$(O)wizard.0	$(O)msdos.0   \
	$(O)termcap.0	$(O)video.0	$(O)vidtxt.0	$(O)zap.0     \
	$(O)explode.0	$(O)shk.0

OVL1 =	$(O)allmain.1	$(O)apply.1	$(O)artifact.1	$(O)attrib.1 \
	$(O)botl.1	$(O)cmd.1	$(O)dbridge.1	$(O)do.1     \
	$(O)do_wear.1	$(O)dog.1	$(O)dungeon.1	$(O)eat.1    \
	$(O)engrave.1	$(O)hack.1	$(O)hacklib.1	$(O)invent.1 \
	$(O)makemon.1	$(O)mhitu.1	$(O)mkobj.1	$(O)mon.1    \
	$(O)mondata.1	$(O)monmove.1	$(O)mthrowu.1	$(O)objnam.1 \
	$(O)pcmain.1	$(O)polyself.1	$(O)rnd.1	$(O)shk.1    \
	$(O)steal.1	$(O)timeout.1	$(O)track.1	$(O)trap.1   \
	$(O)weapon.1	$(O)getline.1	$(O)termcap.1	$(O)topl.1   \
	$(O)video.1	$(O)zap.1	$(O)explode.1

OVL2 =	$(O)attrib.2	$(O)do.2	$(O)do_name.2	$(O)do_wear.2 \
	$(O)dog.2	$(O)engrave.2	$(O)hack.2	$(O)hacklib.2 \
	$(O)invent.2	$(O)makemon.2	$(O)mon.2	$(O)mondata.2 \
	$(O)monmove.2	$(O)getline.2	$(O)shk.2	$(O)topl.2    \
	$(O)trap.2	$(O)zap.2

OVL3 =	$(O)do.3	$(O)hack.3	$(O)invent.3	$(O)light.3   \
	$(O)shk.3	$(O)trap.3	$(O)zap.3


OVLB =	$(O)allmain.B	$(O)apply.B	$(O)artifact.B	$(O)attrib.B	\
	$(O)botl.B	$(O)cmd.B	$(O)dbridge.B	$(O)do.B	\
	$(O)do_name.B	$(O)do_wear.B	$(O)dog.B	$(O)dogmove.B	\
	$(O)eat.B	$(O)engrave.B	$(O)hack.B	$(O)hacklib.B	\
	$(O)invent.B	$(O)lock.B	$(O)mail.B	$(O)makemon.B	\
	$(O)mcastu.B	$(O)mhitm.B	$(O)mhitu.B	$(O)mkobj.B	\
	$(O)mkroom.B	$(O)mon.B	$(O)mondata.B	$(O)monmove.B	\
	$(O)mthrowu.B	$(O)objnam.B	$(O)pcmain.B	$(O)pline.B	\
	$(O)polyself.B	$(O)potion.B	$(O)priest.B	$(O)read.B	\
	$(O)rnd.B	$(O)shk.B	$(O)shknam.B	$(O)sounds.B	\
	$(O)steal.B	$(O)timeout.B	$(O)track.B	$(O)trap.B	\
	$(O)vault.B	$(O)weapon.B	$(O)were.B	$(O)wizard.B	\
	$(O)msdos.B	$(O)pcunix.B	$(O)termcap.B	$(O)topl.B	\
	$(O)video.B	$(O)vidtxt.B	$(O)zap.B

TILOBJ = $(TILEGAME) $(TILEVGA)

VVOBJ =	$(O)version.o

NVOBJ = $(OBJ01)	$(OVL0)		$(OVL1)		$(OVL2) \
	$(OVL3) 	$(OVLB)		$(TILOBJ)

ALLOBJ= $(NVOBJ) $(VVOBJ) $(OVLINIT)

#
# Header objects
#

# This comment copied from sys/unix/Makefile.src,
# extern.h is ignored, even though its declared function types may affect the
# compilation of all the .c files, since extern.h changes every time the
# type of an external function does, and we would spend all our time recompiling
# if we did not ignore it.
#EXTERN_H    = $(INCL)\extern.h
EXTERN_H    =
PCCONF_H    = $(INCL)\pcconf.h $(INCL)\micro.h $(INCL)\system.h
PERMONST_H  = $(INCL)\monattk.h $(INCL)\monflag.h $(INCL)\align.h
YOUPROP_H   = $(INCL)\prop.h $(PERMONST_H) $(INCL)\pm.h $(INCL)\youprop.h \
	      $(INCL)\mondata.h
YOU_H	    = $(INCL)\attrib.h $(INCL)\monst.h $(INCL)\mextra.h $(YOUPROP_H) \
              $(INCL)\align.h
DECL_H      = $(INCL)\quest.h $(INCL)\spell.h $(INCL)\color.h \
	      $(INCL)\obj.h $(YOU_H) $(INCL)\onames.h $(INCL)\pm.h

CONFIG_H    = $(INCL)\config1.h $(INCL)\tradstdc.h $(INCL)\coord.h $(PCCONF_H) \
	      $(INCL)\config.h
HACK_H      = $(CONFIG_H) $(INCL)\context.h $(INCL)\dungeon.h $(INCL)\align.h \
	      $(INCL)\monsym.h $(INCL)\mkroom.h $(INCL)\objclass.h $(DECL_H) \
	      $(INCL)\timeout.h $(INCL)\trap.h $(INCL)\flag.h $(INCL)\rm.h \
	      $(INCL)\vision.h $(INCL)\mondata.h $(INCL)\wintype.h \
	      $(INCL)\engrave.h $(INCL)\rect.h $(EXTERN_H) $(INCL)\sys.h \
	      $(INCL)\winprocs.h $(INCL)\trampoli.h $(INCL)\display.h
TILE_H      = $(INCL)\tile.h $(INCL)\pctiles.h
PCVIDEO_H   = $(INCL)\portio.h $(INCL)\pcvideo.h
ALIGN_H     = $(INCL)\align.h
ARTIFACT_H  = $(INCL)\artifact.h
ARTILIST_H  = $(INCL)\artilist.h
COLOR_H     = $(INCL)\color.h
DATE_H      = $(INCL)\date.h
DLB_H	    = $(INCL)\dlb.h
FUNC_TAB_H  = $(INCL)\func_tab.h
MAIL_H      = $(INCL)\mail.h
MFNDPOS_H   = $(INCL)\mfndpos.h
MONSYM_H    = $(INCL)\monsym.h
OBJ_H       = $(INCL)\obj.h
OBJCLASS_H  = $(INCL)\objclass.h
OBJECTS_H   = $(INCL)\objects.h
PROP_H      = $(INCL)\prop.h
QUEST_H     = $(INCL)\quest.h
SP_LEV_H    = $(INCL)\sp_lev.h
TERMCAP_H   = $(INCL)\tcap.h
WINTTY_H    = $(INCL)\wintty.h

#
# In the unix distribution this file is patchlevel.h, make it 8.3 here
# to avoid an nmake warning under dos.
#

PATCHLEVEL_H   = $(INCL)\patchlev.h


#
#  The name of the game.
#

GAMEFILE = $(GAMEDIR)\$(GAME).exe

#
# make data.base an 8.3 filename to prevent an nmake warning
#

DATABASE = $(DAT)\data.bas

#######################################################################
#
#  TARGETS

#
#  The main target.
#

$(GAME): obj.tag envchk $(U)utility.tag $(GAMEFILE)
	@echo $(GAME) is up to date.

#
#  Everything
#

all :	install

install: $(GAME) install.tag
	@echo Done.


install.tag: 	$(DAT)\data	$(DAT)\rumors	$(DAT)\dungeon \
	 	$(DAT)\oracles	$(DAT)\quest.dat $(DLB)
! IF ("$(USE_DLB)"=="Y")
	copy nhdat                $(GAMEDIR)
	copy $(DAT)\license       $(GAMEDIR)
! ELSE
	copy $(DAT)\*.            $(GAMEDIR)
	copy $(DAT)\*.dat         $(GAMEDIR)
	copy $(DAT)\*.lua         $(GAMEDIR)
	copy $(MSYS)\msdoshlp.txt $(GAMEDIR)
	if exist $(GAMEDIR)\makefile del $(GAMEDIR)\makefile
! ENDIF
	copy $(SYS)\termcap       $(GAMEDIR)
	if exist $(DAT)\symbols copy $(DAT)\symbols $(GAMEDIR)
	if exist $(DOC)\guideb*.txt copy $(DOC)\guideb*.txt  $(GAMEDIR)
	if exist $(DOC)\nethack.txt copy $(DOC)\nethack.txt  $(GAMEDIR)\NetHack.txt
	if exist $(DOC)\recover.txt copy $(DOC)\recover.txt  $(GAMEDIR)
	copy $(SYS)\NetHack.cnf   $(GAMEDIR)\defaults.nh
	copy $(MSYS)\NHAccess.nh  $(GAMEDIR)
	copy $(U)recover.exe  $(GAMEDIR)
	if exist *.tib copy *.tib $(GAMEDIR)
	echo install done > $@

$(U)utility.tag: envchk			$(INCL)\date.h	$(INCL)\onames.h \
		$(INCL)\pm.h 		$(U)recover.exe		$(TILEUTIL)
             @echo utilities made >$@
	     @echo utilities made.

tileutil: $(U)gif2txt.exe $(U)txt2ppm.exe
	@echo Optional tile development utilities are up to date.

#
#  Inline files :
#			Specifying the "<<" means to start an inline file.
#                 	Another "<<" at the start of a line closes the
#                 	inline file.
#
#  DO NOT INDENT THE << below!
#

$(GAMEFILE) :  $(ALLOBJ)
	@echo Linking....
	$(LINK) $(LFLAGSN) @<<$(GAME).lnk
		$(ALLOBJ)
		$(GAMEFILE)
		$(GAME)
		$(TERMLIB) $(MOVETR) $(CLIB) $(BCOVL) $(BCMDL)
<<
	@if exist $(GAMEDIR)\$(GAME).bak del $(GAMEDIR)\$(GAME).bak

#
# Makedefs Stuff
#

$(U)makedefs.exe:	$(MAKEOBJS)
	@$(LINK) $(LFLAGSU) $(MAKEOBJS), $@,, $(CLIB) $(BCMDL);

$(O)makedefs.o: $(CONFIG_H)	    $(PERMONST_H)      $(OBJCLASS_H) \
		 $(MONSYM_H)    $(PATCHLEVEL_H) \
		 $(U)makedefs.c
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	@$(CC) $(CFLAGSU) $(COBJNAM)$@ $(U)makedefs.c

#
#  date.h should be remade every time any of the source or include
#  files is modified.
#

$(INCL)\date.h : $(U)makedefs.exe
	$(U)makedefs -v
	@echo A new $@ has been created.

$(INCL)\onames.h : $(U)makedefs.exe
	$(U)makedefs -o

$(INCL)\pm.h : $(U)makedefs.exe
	$(U)makedefs -p

#$(INCL)\trap.h : $(U)makedefs.exe
#	$(U)makedefs -t

obj.tag:
	@if not exist $(O)*.* mkdir $(OBJ)
	@echo directory $(OBJ) created
	@echo directory $(OBJ) created >$@

envchk: precomp.msg
!	IF "$(TILEGAME)"==""
	   @echo.
	   @echo NOTE: This build will NOT include tile support.
	   @echo.
!	ELSE
	   @echo.
	   @echo This build includes tile support.
	   @echo.
!	ENDIF

#
# SECONDARY TARGETS
#

#
# Header files NOT distributed in ..\include
#

$(INCL)\tile.h: $(WSHR)\tile.h
	copy $(WSHR)\tile.h $@

$(INCL)\pctiles.h: $(MSYS)\pctiles.h
	copy $(MSYS)\pctiles.h $@

$(INCL)\pcvideo.h: $(MSYS)\pcvideo.h
	copy $(MSYS)\pcvideo.h $@

$(INCL)\portio.h: $(MSYS)\portio.h
	copy $(MSYS)\portio.h $@

#
#  Recover Utility
#

$(U)recover.exe: $(RECOVOBJS)
	@$(LINK) $(LFLAGSU) $(RECOVOBJS),$@,, $(CLIB) $(BCMDL);

#
#  Tile Mapping
#

$(SRC)\tile.c: $(U)tilemap.exe
	@echo A new $@ is being created.
	@$(U)tilemap

$(U)tilemap.exe: $(O)tilemap.o
	@$(LINK) $(LFLAGSU) $(O)tilemap.o,$@,, $(CLIB) $(BCMDL);

$(O)tilemap.o:  $(WSHR)\tilemap.c $(HACK_H)
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(WSHR)\tilemap.c


#
# Tile Utilities
#

#
#  Optional (for development)
#



#

$(U)gif2txt.exe: $(GIFREADERS) $(TEXT_IO)
	@$(LINK) $(LFLAGSU) << $(@B).lnk
		$(GIFREADERS) $(TEXT_IO)
		$@,,$(CLIB) $(BCMDL)
<<

$(U)txt2ppm.exe: $(PPMWRITERS) $(TEXT_IO)
	@$(LINK) $(LFLAGSU) << $(@B).lnk
		$(PPMWRITERS) $(TEXT_IO)
		$@,,$(CLIB) $(BCMDL);
<<

$(U)gif2txt2.exe: $(GIFREAD2) $(TEXT_IO2)
	@$(LINK) $(LFLAGSU) << $(@B).lnk
		$(GIFREAD2) $(TEXT_IO2)
		$@,,$(CLIB) $(BCMDL);
<<

$(U)txt2ppm2.exe: $(PPMWRIT2) $(TEXT_IO2)
	@$(LINK) $(LFLAGSU) << $(@B).lnk
		$(PPMWRIT2) $(TEXT_IO2)
		$@,,$(CLIB) $(BCMDL);
<<

#
#  Required for tile support
#

NetHack1.tib: $(TILEFILES) $(U)tile2bin.exe
	@echo Creating binary tile files (this may take some time)
	@$(U)tile2bin

NetHackO.tib: thintile.tag $(TILEFILES2) $(U)til2bin2.exe
	@echo Creating overview binary tile files (this may take some time)
	@$(U)til2bin2

thintile.tag: $(U)thintile.exe $(TILEFILES)
	$(U)thintile
	@echo thintiles created >thintile.tag

$(U)tile2bin.exe: $(O)tile2bin.o $(TEXT_IO)
    @echo Linking $@...
	$(LINK) $(LFLAGSU) @&&!
		$(O)tile2bin.o+
		$(O)stubvid.o $(O)objects.o $(O)monst.o $(O)decl.o +
		$(O)drawing.o $(O)tiletxt.o $(O)tiletext.o 
		$@
		$(@B)
		$(BCMDL);
!

$(U)til2bin2.exe: $(O)til2bin2.o $(TEXT_IO2)
    @echo Linking $@...
	$(LINK) $(LFLAGSU) @&&!
		$(O)til2bin2.o+
		$(O)stubvid.o $(O)objects.o $(O)monst.o $(O)decl.o +
		$(O)drawing.o $(O)tiletxt2.o $(O)tiletex2.o 
		$@
		$(@B)
		$(BCMDL);
!


$(U)thintile.exe: $(O)thintile.o
	@$(LINK) $(LFLAGSU) $(O)thintile.o,$@,, $(CLIB) $(BCMDL);

$(O)thintile.o:  $(HACK_H) $(INCL)\tile.h $(WSHR)\thintile.c
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(WSHR)\thintile.c

$(O)tile2bin.o:  $(HACK_H) $(TILE_H) $(PCVIDEO_H)
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(MSYS)\tile2bin.c

$(O)til2bin2.o:  $(HACK_H) $(TILE_H) $(PCVIDEO_H)
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSU) $(CDEFINE)TILE_X=8 $(CDEFINE)OVERVIEW_FILE \
		$(COBJNAM)$@ $(MSYS)\tile2bin.c


#
# DLB stuff
#

nhdat:	$(U)dlb_main.exe
	@copy $(MSYS)\msdoshlp.txt $(DAT)
	@cd $(DAT)
	@echo data >dlb.lst
	@echo oracles >>dlb.lst
	@echo options >>dlb.lst
	@echo quest.dat >>dlb.lst
	@echo rumors >>dlb.lst
	@echo help >>dlb.lst
	@echo hh >>dlb.lst
	@echo cmdhelp >>dlb.lst
	@echo history >>dlb.lst
	@echo opthelp >>dlb.lst
	@echo wizhelp >>dlb.lst
	@echo dungeon >>dlb.lst
	@echo license >>dlb.lst
	@echo msdoshlp.txt >>dlb.lst
	@for %%N in (*.lua) do echo %%N >>dlb.lst
	$(U)dlb_main cvIf dlb.lst $(SRC)\nhdat
	@cd $(SRC)

$(U)dlb_main.exe: $(DLBOBJS)
	@$(LINK) $(LFLAGSU) $(DLBOBJS),$@,, $(CLIB) $(BCMDL);

$(O)dlb_main.o: $(U)dlb_main.c $(INCL)\config.h $(DLB_H)
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(U)dlb_main.c

#
# Housekeeping
#

spotless: clean
	rmdir $(OBJ)
	if exist $(DATE_H)    del $(DATE_H)
	if exist $(INCL)\onames.h  del $(INCL)\onames.h
	if exist $(INCL)\pm.h      del $(INCL)\pm.h
	if exist $(SRC)\tile.c     del $(SRC)\tile.c
	if exist $(DAT)\rumors     del $(DAT)\rumors
	if exist $(DAT)\data		del $(DAT)\data
	if exist $(DAT)\dungeon		del $(DAT)\dungeon
	if exist $(DAT)\dungeon.pdf	del $(DAT)\dungeon.pdf
	if exist $(DAT)\options		del $(DAT)\options
	if exist $(DAT)\oracles		del $(DAT)\oracles
	if exist $(DAT)\rumors		del $(DAT)\rumors
	if exist $(SRC)\$(PLANAR_TIB)   del $(SRC)\$(PLANAR_TIB)
	if exist $(SRC)\$(OVERVIEW_TIB) del $(SRC)\$(OVERVIEW_TIB)
	if exist $(U)recover.exe        del $(U)recover.exe

clean:
	if exist $(O)*.o del $(O)*.o
	if exist $(O)*.0 del $(O)*.0
	if exist $(O)*.1 del $(O)*.1
	if exist $(O)*.2 del $(O)*.2
	if exist $(O)*.3 del $(O)*.3
	if exist $(O)*.b del $(O)*.b
	if exist $(U)utility.tag   del $(U)utility.tag
	if exist $(U)makedefs.exe  del $(U)makedefs.exe
	if exist $(U)dlb_main.exe  del $(U)dlb_main.exe
	if exist $(SRC)\*.lnk      del $(SRC)\*.lnk
	if exist $(SRC)\*.map      del $(SRC)\*.map
	if exist $(SRC)\*$(CPCHEXT) del $(SRC)\*$(CPCHEXT)
	if exist $(SRC)\*.cfg      del $(SRC)\*.cfg
	if exist $(DAT)\dlb.lst    del $(DAT)\dlb.lst

pch.c:	$(HACK_H)
	@echo ^#include "hack.h" > $@
	@echo main(int argc, char *argv[]) >> $@
	@echo { >> $@
	@echo } >> $@
	@echo. >> $@

#
# OTHER DEPENDENCIES
#

#
# Precompiled Header dependencies
# (We need to force the generation of these at the beginning)
#

PHO$(CPCHEXT): $(HACK_H) pch.c
	@echo Generating new precompiled header for .O files
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGCO) >> $(VROOMMCFG)
	@$(CC) $(FLAGCO) pch.c
PH0$(CPCHEXT): $(HACK_H) pch.c
	@echo Generating new precompiled header for .0 files
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGC0) >> $(VROOMMCFG)
	@$(CC) $(FLAGC0) pch.c
PH1$(CPCHEXT): $(HACK_H) pch.c
	@echo Generating new precompiled header for .1 files
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGC1) >> $(VROOMMCFG)
	@$(CC) $(FLAGC1) pch.c
PH2$(CPCHEXT): $(HACK_H) pch.c
	@echo Generating new precompiled header for .2 files
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGC2) >> $(VROOMMCFG)
	@$(CC) $(FLAGC2) pch.c
PH3$(CPCHEXT): $(HACK_H) pch.c
	@echo Generating new precompiled header for .3 files
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGC3) >> $(VROOMMCFG)
	@$(CC) $(FLAGC3) pch.c
PHB$(CPCHEXT): $(HACK_H) pch.c
	@echo Generating new precompiled header for .B files
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGCB) >> $(VROOMMCFG)
	@$(CC) $(FLAGCB) pch.c


# Overlay initialization routines used by pcmain() at startup to
# determine EMS/XMS memory usage.

# Comment out the following line if you don't want Borland C++ to check for
# extended memory.
RECOGNIZE_XMS = $(CDEFINE)RECOGNIZE_XMS


$(O)ovlinit.o: $(MSYS)\ovlinit.c $(HACK_H)
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSN) $(RECOGNIZE_XMS) $(COBJNAM)$@ $(MSYS)\ovlinit.c

#
# dat dependencies
#

$(DAT)\data: $(U)utility.tag    $(DATABASE)
	$(U)makedefs -d

$(DAT)\rumors: $(U)utility.tag    $(DAT)\rumors.tru   $(DAT)\rumors.fal
	$(U)makedefs -r

$(DAT)\quest.dat: $(U)utility.tag  $(DAT)\quest.txt
	$(U)makedefs -q

$(DAT)\oracles: $(U)utility.tag    $(DAT)\oracles.txt
	$(U)makedefs -h

$(DAT)\dungeon: $(U)utility.tag  $(DAT)\dungeon.def
	$(U)makedefs -e
	cd $(DAT)
	$(U)dgn_comp dungeon.pdf
	cd $(SRC)

#
#  Util Dependencies.
#

$(O)panic.o:   $(U)panic.c $(CONFIG_H)
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(U)panic.c

$(O)recover.o: $(CONFIG_H) $(U)recover.c
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(U)recover.c

#
#  from win\share
#

$(O)tiletxt.o:  $(WSHR)\tilemap.c $(HACK_H)
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSU) $(CDEFINE)TILETEXT $(COBJNAM)$@ $(WSHR)\tilemap.c

$(O)tiletxt2.o:  $(WSHR)\tilemap.c $(HACK_H)
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSU) $(CDEFINE)TILETEXT \
		$(CDEFINE)TILE_X=8 $(COBJNAM)$@ $(WSHR)\tilemap.c

$(O)gifread.o:  $(WSHR)\gifread.c  $(CONFIG_H) $(INCL)\tile.h
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(WSHR)\gifread.c

$(O)gifread2.o:  $(WSHR)\gifread.c  $(CONFIG_H) $(INCL)\tile.h
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(CDEFINE)TILE_X=8 $(WSHR)\gifread.c

$(O)ppmwrite.o: $(WSHR)\ppmwrite.c $(CONFIG_H) $(INCL)\tile.h
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(WSHR)\ppmwrite.c

$(O)ppmwrit2.o: $(WSHR)\ppmwrite.c $(CONFIG_H) $(INCL)\tile.h
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(CDEFINE)TILE_X=8 $(WSHR)\ppmwrite.c

$(O)tiletext.o:   $(WSHR)\tiletext.c  $(CONFIG_H) $(INCL)\tile.h
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSU) $(COBJNAM)$@ $(WSHR)\tiletext.c

$(O)tiletex2.o:   $(WSHR)\tiletext.c  $(CONFIG_H) $(INCL)\tile.h
	@echo $(BCOPTS1) > $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSU) $(CDEFINE)TILE_X=8 $(COBJNAM)$@ $(WSHR)\tiletext.c

#
#  from win\tty
#

$(O)getline.1:  $(PCH1) $(WTTY)\getline.c  $(HACK_H) $(WINTTY_H) $(FUNC_TAB_H)
	@type schema$(SCHEMA).bc | find "$(@B)_1" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU1) >> $(VROOMMCFG)
	$(CC) $(FLAGU1) $(COBJNAM)$@ $(WTTY)\getline.c

$(O)getline.2:  $(PCH2) $(WTTY)\getline.c  $(HACK_H) $(WINTTY_H) $(FUNC_TAB_H)
	@type schema$(SCHEMA).bc | find "$(@B)_2" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU2) >> $(VROOMMCFG)
	$(CC) $(FLAGU2) $(COBJNAM)$@ $(WTTY)\getline.c

$(O)termcap.0:  $(PCH0) $(WTTY)\termcap.c  $(HACK_H) $(WINTTY_H) $(TERMCAP_H)
	@type schema$(SCHEMA).bc | find "$(@B)_0" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU0) >> $(VROOMMCFG)
	$(CC) $(FLAGU0) $(COBJNAM)$@ $(WTTY)\termcap.c

$(O)termcap.1:  $(PCH1) $(WTTY)\termcap.c  $(HACK_H) $(WINTTY_H) $(TERMCAP_H)
	@type schema$(SCHEMA).bc | find "$(@B)_1" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU1) >> $(VROOMMCFG)
	$(CC) $(FLAGU1) $(COBJNAM)$@ $(WTTY)\termcap.c

$(O)termcap.B:  $(PCHB) $(WTTY)\termcap.c  $(HACK_H) $(WINTTY_H) $(TERMCAP_H)
	@type schema$(SCHEMA).bc | find "$(@B)_b" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUB) >> $(VROOMMCFG)
	$(CC) $(FLAGUB) $(COBJNAM)$@ $(WTTY)\termcap.c

$(O)topl.1:     $(PCH1) $(WTTY)\topl.c     $(HACK_H) $(TERMCAP_H) $(WINTTY_H)
	@type schema$(SCHEMA).bc | find "$(@B)_1" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU1) >> $(VROOMMCFG)
	$(CC) $(FLAGU1) $(COBJNAM)$@ $(WTTY)\topl.c

$(O)topl.2:     $(PCH2) $(WTTY)\topl.c     $(HACK_H) $(TERMCAP_H) $(WINTTY_H)
	@type schema$(SCHEMA).bc | find "$(@B)_2" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU2) >> $(VROOMMCFG)
	$(CC) $(FLAGU2) $(COBJNAM)$@ $(WTTY)\topl.c

$(O)topl.B:     $(PCHB) $(WTTY)\topl.c     $(HACK_H) $(TERMCAP_H) $(WINTTY_H)
	@type schema$(SCHEMA).bc | find "$(@B)_b" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUB) >> $(VROOMMCFG)
	$(CC) $(FLAGUB) $(COBJNAM)$@ $(WTTY)\topl.c

$(O)wintty.o: $(PCHO) $(CONFIG_H) $(WTTY)\wintty.c $(PATCHLEVEL_H) $(DATE_H)
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUO) >> $(VROOMMCFG)
	$(CC) $(FLAGUO) $(COBJNAM)$@ $(WTTY)\wintty.c

#
# from sys\share
#

$(O)pcmain.0:   $(PCH0) $(HACK_H) $(SYS)\pcmain.c
	@type schema$(SCHEMA).bc | find "$(@B)_0" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU0) >> $(VROOMMCFG)
	$(CC)  $(FLAGU0) $(COBJNAM)$@ $(SYS)\pcmain.c

$(O)pcmain.1:   $(PCH1) $(HACK_H) $(SYS)\pcmain.c
	@type schema$(SCHEMA).bc | find "$(@B)_1" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU1) >> $(VROOMMCFG)
	$(CC)  $(FLAGU1) $(COBJNAM)$@ $(SYS)\pcmain.c

$(O)pcmain.B:   $(PCHB) $(HACK_H) $(SYS)\pcmain.c
	@type schema$(SCHEMA).bc | find "$(@B)_b" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUB) >> $(VROOMMCFG)
	$(CC)  $(FLAGUB) $(COBJNAM)$@ $(SYS)\pcmain.c

$(O)pcunix.B:   $(PCHB) $(SYS)\pcunix.c   $(HACK_H)
	@type schema$(SCHEMA).bc | find "$(@B)_b" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUB) >> $(VROOMMCFG)
	$(CC) $(FLAGUB) $(COBJNAM)$@ $(SYS)\pcunix.c

$(O)tty.o:     $(HACK_H) $(WINTTY_H) $(SYS)\pctty.c
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC)  $(CFLAGSN) $(COBJNAM)$@  $(SYS)\pctty.c

$(O)pcsys.o:    $(HACK_H) $(SYS)\pcsys.c
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC)  $(CFLAGSN) $(COBJNAM)$@ $(SYS)\pcsys.c

$(O)random.o: $(PCHO) $(HACK_H) $(SYS)\random.c
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUO) >> $(VROOMMCFG)
	$(CC) $(FLAGUO) $(COBJNAM)$@ $(SYS)\random.c

#
# from sys\msdos
#

$(O)msdos.0: $(MSYS)\msdos.c   $(HACK_H) $(PCVIDEO_H)
	@type schema$(SCHEMA).bc | find "$(@B)_0" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSN) $(COVL0) $(COBJNAM)$@ $(MSYS)\msdos.c

$(O)msdos.B: $(MSYS)\msdos.c   $(HACK_H) $(PCVIDEO_H)
	@type schema$(SCHEMA).bc | find "$(@B)_b" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2)  >> $(VROOMMCFG)
	$(CC) $(CFLAGSN) $(COVLB) $(COBJNAM)$@ $(MSYS)\msdos.c

$(O)pctiles.0: $(PCH0) $(MSYS)\pctiles.c $(HACK_H) $(TILE_H) $(PCVIDEO_H)
	@type schema$(SCHEMA).bc | find "$(@B)_0" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU0) >> $(VROOMMCFG)
	$(CC) $(FLAGU0) $(COBJNAM)$@ $(MSYS)\pctiles.c

$(O)pctiles.B: $(PCHB) $(MSYS)\pctiles.c $(HACK_H) $(TILE_H) $(PCVIDEO_H)
	@type schema$(SCHEMA).bc | find "$(@B)_b" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUB) >> $(VROOMMCFG)
	$(CC) $(FLAGUB) $(COBJNAM)$@ $(MSYS)\pctiles.c

$(O)pckeys.o: $(PCHO) $(MSYS)\pckeys.c   $(HACK_H) $(PCVIDEO_H)
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUO) >> $(VROOMMCFG)
	$(CC) $(FLAGUO) $(COBJNAM)$@ $(MSYS)\pckeys.c

$(O)stubvid.o : $(MSYS)\video.c $(HACK_H)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUO) >> $(VROOMMCFG)
	$(CC) $(FLAGUO) $(CDEFINE)STUBVIDEO $(COBJNAM)$@ $(MSYS)\video.c

$(O)video.0: $(PCH0) $(MSYS)\video.c   $(HACK_H) $(WINTTY_H) $(PCVIDEO_H) \
                $(TILE_H)
	@type schema$(SCHEMA).bc | find "$(@B)_0" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU0) >> $(VROOMMCFG)
	$(CC) $(FLAGU0) $(COBJNAM)$@ $(MSYS)\video.c

$(O)video.1: $(PCH1) $(MSYS)\video.c   $(HACK_H) $(WINTTY_H) $(PCVIDEO_H) \
                $(TILE_H)
	@type schema$(SCHEMA).bc | find "$(@B)_1" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU1) >> $(VROOMMCFG)
	$(CC) $(FLAGU1) $(COBJNAM)$@ $(MSYS)\video.c

$(O)video.B: $(PCHB) $(MSYS)\video.c   $(HACK_H) $(WINTTY_H) $(PCVIDEO_H) \
                $(TILE_H)
	@type schema$(SCHEMA).bc | find "$(@B)_b" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUB) >> $(VROOMMCFG)
	$(CC) $(FLAGUB) $(COBJNAM)$@ $(MSYS)\video.c

$(O)vidtxt.0: $(MSYS)\vidtxt.c  $(HACK_H) $(WINTTY_H) $(PCVIDEO_H)
	@type schema$(SCHEMA).bc | find "$(@B)_0" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSN) $(COVL0) $(COBJNAM)$@ $(MSYS)\vidtxt.c

$(O)vidtxt.B: $(MSYS)\vidtxt.c  $(HACK_H) $(WINTTY_H) $(PCVIDEO_H)
	@type schema$(SCHEMA).bc | find "$(@B)_b" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSN) $(COVLB) $(COBJNAM)$@ $(MSYS)\vidtxt.c

$(O)vidvga.0: $(PCH0) $(MSYS)\vidvga.c  $(HACK_H) $(WINTTY_H) $(PCVIDEO_H) \
		$(TILE_H)
	@type schema$(SCHEMA).bc | find "$(@B)_0" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU0) >> $(VROOMMCFG)
	$(CC) $(FLAGU0) $(COBJNAM)$@ $(MSYS)\vidvga.c

$(O)vidvga.1: $(PCH1) $(MSYS)\vidvga.c  $(HACK_H) $(WINTTY_H) $(PCVIDEO_H) \
		$(TILE_H)
	@type schema$(SCHEMA).bc | find "$(@B)_1" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU1) >> $(VROOMMCFG)
	$(CC) $(FLAGU1) $(COBJNAM)$@ $(MSYS)\vidvga.c

$(O)vidvga.2: $(PCH2) $(MSYS)\vidvga.c  $(HACK_H) $(WINTTY_H) $(PCVIDEO_H) \
		$(TILE_H)
	@type schema$(SCHEMA).bc | find "$(@B)_2" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGU2) >> $(VROOMMCFG)
	$(CC) $(FLAGU2) $(COBJNAM)$@ $(MSYS)\vidvga.c

$(O)vidvga.B: $(PCHB) $(MSYS)\vidvga.c  $(HACK_H) $(WINTTY_H) $(PCVIDEO_H) \
		$(TILE_H)
	@type schema$(SCHEMA).bc | find "$(@B)_b" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) $(CFLAGUB) >> $(VROOMMCFG)
	$(CC) $(FLAGUB) $(COBJNAM)$@ $(MSYS)\vidvga.c

#
# from src
#

$(O)alloc.o:     $(SRC)\alloc.c    $(CONFIG_H)
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSN) $(COBJNAM)$@ $(SRC)\alloc.c
$(O)ball.o:      $(PCHO) $(SRC)\ball.c     $(HACK_H)
$(O)bones.o:     $(PCHO) $(SRC)\bones.c    $(HACK_H)
$(O)decl.o:      $(PCHO) $(SRC)\decl.c     $(HACK_H) $(QUEST_H)
$(O)detect.o:    $(PCHO) $(SRC)\detect.c   $(HACK_H) $(ARTIFACT_H)
$(O)dig.o:	 $(PCHO) $(SRC)\dig.c	   $(HACK_H) # check dep
$(O)display.o:	 $(PCHO) $(SRC)\display.c  $(HACK_H)
$(O)dlb.o:	 $(SRC)\dlb.c	   $(DLB_H) $(HACK_H)
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSN) $(COBJNAM)$@ $(SRC)\dlb.c
$(O)dokick.o:    $(PCHO) $(SRC)\dokick.c   $(HACK_H)
$(O)dothrow.o:   $(PCHO) $(SRC)\dothrow.c  $(HACK_H)
$(O)drawing.o:   $(SRC)\drawing.c  $(HACK_H) $(TERMCAP_H)
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSN) $(COBJNAM)$@ $(SRC)\drawing.c
$(O)end.o:       $(SRC)\end.c      $(HACK_H) $(DLB_H)
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSN) $(COBJNAM)$@ $(SRC)\end.c
$(O)exper.o:     $(PCHO) $(SRC)\exper.c    $(HACK_H)
$(O)extralev.o:  $(PCHO) $(SRC)\extralev.c $(HACK_H)
$(O)files.o:	 $(PCHO) $(SRC)\files.c    $(HACK_H) $(DLB_H)
$(O)fountain.o:  $(PCHO) $(SRC)\fountain.c $(HACK_H)
$(O)mapglyph.o:  $(PCHO) $(SRC)\mapglyph.c $(HACK_H)
$(O)minion.o:    $(PCHO) $(SRC)\minion.c   $(HACK_H)
$(O)mklev.o:     $(PCHO) $(SRC)\mklev.c    $(HACK_H)
$(O)mkmap.o:     $(PCHO) $(SRC)\mkmap.c    $(HACK_H) $(SP_LEV_H)
$(O)mkmaze.o:	 $(PCHO) $(SRC)\mkmaze.c   $(HACK_H) $(SP_LEV_H)
$(O)monst.o:     $(SRC)\monst.c    $(CONFIG_H) $(PERMONST_H) $(MONSYM_H) \
		 $(COLOR_H) $(ALIGN_H)
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSN) $(COBJNAM)$@ $(SRC)\monst.c
$(O)mplayer.o:   $(PCHO) $(SRC)\mplayer.c  $(HACK_H)
$(O)muse.o:      $(PCHO) $(SRC)\muse.c     $(HACK_H)
$(O)music.o:     $(PCHO) $(SRC)\music.c    $(HACK_H)
$(O)o_init.o:	 $(PCHO) $(SRC)\o_init.c   $(HACK_H)
$(O)objects.o:   $(SRC)\objects.c  $(CONFIG_H) $(OBJ_H) $(OBJCLASS_H) \
                 $(PROP_H) $(COLOR_H)
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSN) $(COBJNAM)$@ $(SRC)\objects.c
$(O)options.o:	 $(SRC)\options.c  $(HACK_H) $(TERMCAP_H) $(OBJCLASS_H)
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSN) $(COBJNAM)$@ $(SRC)\options.c
$(O)pager.o:	 $(SRC)\pager.c    $(HACK_H) $(DLB_H)
	@type schema$(SCHEMA).bc | find "$(@B)_o" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGNO) $(COBJNAM)$@ $(SRC)\pager.c
$(O)pickup.o:    $(PCHO) $(SRC)\pickup.c   $(HACK_H)
$(O)pray.o:      $(PCHO) $(SRC)\pray.c     $(HACK_H)
$(O)quest.o:     $(PCHO) $(SRC)\quest.c    $(HACK_H) $(QUEST_H)
$(O)questpgr.o:  $(PCHO) $(SRC)\questpgr.c $(HACK_H) $(DLB_H)
$(O)rect.o:      $(PCHO) $(SRC)\rect.c     $(HACK_H)
$(O)region.o:    $(PCHO) $(SRC)\region.c   $(HACK_H)
$(O)restore.o:   $(PCHO) $(SRC)\restore.c  $(HACK_H) $(TERMCAP_H) \
		 $(QUEST_H)
$(O)rip.o:       $(PCHO) $(SRC)\rip.c      $(HACK_H)
$(O)role.o:	   $(PCHO) $(SRC)\role.c     $(HACK_H)
$(O)rumors.o:	 $(PCHO) $(SRC)\rumors.c   $(HACK_H) $(DLB_H)
$(O)save.o:      $(PCHO) $(SRC)\save.c     $(HACK_H) $(QUEST_H)
$(O)sit.o:       $(PCHO) $(SRC)\sit.c      $(HACK_H) $(ARTIFACT_H)
$(O)steed.o:	   $(PCHO) $(SRC)\steed.c    $(HACK_H)
$(O)sys.o:	 $(PCHO) $(SRC)\sys.c      $(HACK_H)
$(O)sp_lev.o:	 $(PCHO) $(SRC)\sp_lev.c   $(HACK_H) $(SP_LEV_H) $(DLB_H)
$(O)spell.o:     $(PCHO) $(SRC)\spell.c    $(HACK_H)
$(O)teleport.o:  $(PCHO) $(SRC)\teleport.c $(HACK_H)	# check dep
$(O)tile.o:      $(PCHO) $(SRC)\tile.c     $(HACK_H)
$(O)topten.o:	 $(PCHO) $(SRC)\topten.c   $(HACK_H) $(DLB_H) $(PATCHLEVEL_H)
$(O)u_init.o:    $(PCHO) $(SRC)\u_init.c   $(HACK_H)
$(O)uhitm.o:     $(PCHO) $(SRC)\uhitm.c    $(HACK_H)
$(O)version.o:   $(PCHO) $(SRC)\version.c  $(HACK_H) $(PATCHLEVEL_H)
$(O)vision.o:    $(PCHO) $(SRC)\vision.c
$(O)wield.o:     $(PCHO) $(SRC)\wield.c    $(HACK_H)
$(O)windows.o:   $(PCHO) $(SRC)\windows.c  $(HACK_H) $(WINTTY_H)
$(O)worm.o:      $(PCHO) $(SRC)\worm.c     $(HACK_H)
$(O)worn.o:      $(PCHO) $(SRC)\worn.c     $(HACK_H)
$(O)write.o:     $(PCHO) $(SRC)\write.c    $(HACK_H)

#
# Overlays
#

# OVL0
#

$(O)allmain.0:  $(PCH0) $(SRC)\allmain.c  $(HACK_H)
$(O)apply.0:    $(PCH0) $(SRC)\apply.c    $(HACK_H)
$(O)artifact.0: $(PCH0) $(SRC)\artifact.c $(HACK_H) $(ARTIFACT_H) $(ARTILIST_H)
$(O)attrib.0:   $(PCH0) $(SRC)\attrib.c   $(HACK_H)
$(O)botl.0:     $(PCH0) $(SRC)\botl.c     $(HACK_H)
$(O)cmd.0:      $(PCH0) $(SRC)\cmd.c      $(HACK_H) $(FUNC_TAB_H)
$(O)dbridge.0:  $(PCH0) $(SRC)\dbridge.c  $(HACK_H)
$(O)do.0:       $(PCH0) $(SRC)\do.c       $(HACK_H)
$(O)do_name.0:  $(PCH0) $(SRC)\do_name.c  $(HACK_H)
$(O)do_wear.0:  $(PCH0) $(SRC)\do_wear.c  $(HACK_H)
$(O)dogmove.0:  $(PCH0) $(SRC)\dogmove.c  $(HACK_H) $(MFNDPOS_H)
$(O)dungeon.0:	$(PCH0) $(SRC)\dungeon.c  $(HACK_H) $(ALIGN_H) $(DGN_FILE_H) \
		$(DLB_H)
$(O)eat.0:      $(PCH0) $(SRC)\eat.c      $(HACK_H)
$(O)engrave.0:  $(PCH0) $(SRC)\engrave.c  $(HACK_H)
$(O)explode.0:  $(PCH0) $(SRC)\explode.c  $(HACK_H)
$(O)hacklib.0:  $(PCH0) $(SRC)\hacklib.c  $(HACK_H)
$(O)invent.0:   $(PCH0) $(SRC)\invent.c   $(HACK_H) $(ARTIFACT_H)
$(O)lock.0:     $(PCH0) $(SRC)\lock.c     $(HACK_H)
$(O)mail.0:     $(PCH0) $(SRC)\mail.c     $(HACK_H) $(MAIL_H) $(DATE_H)
$(O)makemon.0:  $(PCH0) $(SRC)\makemon.c  $(HACK_H)
$(O)mcastu.0:   $(PCH0) $(SRC)\mcastu.c   $(HACK_H)
$(O)mhitm.0:    $(PCH0) $(SRC)\mhitm.c    $(HACK_H) $(ARTIFACT_H)
$(O)mhitu.0:    $(PCH0) $(SRC)\mhitu.c    $(HACK_H) $(ARTIFACT_H)
$(O)mkobj.0:    $(PCH0) $(SRC)\mkobj.c    $(HACK_H) $(ARTIFACT_H) $(PROP_H)
$(O)mkroom.0:   $(PCH0) $(SRC)\mkroom.c   $(HACK_H)
$(O)mon.0:      $(PCH0) $(SRC)\mon.c      $(HACK_H) $(MFNDPOS_H)
$(O)mondata.0:  $(PCH0) $(SRC)\mondata.c  $(HACK_H)
$(O)monmove.0:  $(PCH0) $(SRC)\monmove.c  $(HACK_H) $(MFNDPOS_H) $(ARTIFACT_H)
$(O)mthrowu.0:  $(PCH0) $(SRC)\mthrowu.c  $(HACK_H)
$(O)objnam.0:   $(PCH0) $(SRC)\objnam.c   $(HACK_H)
$(O)polyself.0: $(PCH0) $(SRC)\polyself.c $(HACK_H)
$(O)priest.0:   $(PCH0) $(SRC)\priest.c   $(HACK_H) $(MFNDPOS_H)
$(O)rnd.0:      $(PCH0) $(SRC)\rnd.c      $(HACK_H)
$(O)shk.0:      $(PCH0) $(SRC)\shk.c      $(HACK_H)
$(O)shknam.0:   $(PCH0) $(SRC)\shknam.c   $(HACK_H)
$(O)sounds.0:   $(PCH0) $(SRC)\sounds.c   $(HACK_H)
$(O)steal.0:    $(PCH0) $(SRC)\steal.c    $(HACK_H)
$(O)timeout.0:	$(PCH0) $(SRC)\timeout.c  $(HACK_H)
$(O)track.0:    $(PCH0) $(SRC)\track.c    $(HACK_H)
$(O)trap.0:     $(PCH0) $(SRC)\trap.c     $(HACK_H)
$(O)vault.0:    $(PCH0) $(SRC)\vault.c    $(HACK_H)
$(O)weapon.0:   $(PCH0) $(SRC)\weapon.c   $(HACK_H)
$(O)were.0:     $(PCH0) $(SRC)\were.c     $(HACK_H)
$(O)wizard.0:   $(PCH0) $(SRC)\wizard.c   $(HACK_H)
$(O)zap.0:      $(PCH0) $(SRC)\zap.c      $(HACK_H)

#
# OVL1
#

$(O)allmain.1:  $(PCH1) $(SRC)\allmain.c  $(HACK_H)
$(O)apply.1:    $(PCH1) $(SRC)\apply.c    $(HACK_H)
$(O)artifact.1: $(PCH1) $(SRC)\artifact.c $(HACK_H) $(ARTIFACT_H) $(ARTILIST_H)
$(O)attrib.1:   $(PCH1) $(SRC)\attrib.c   $(HACK_H)
$(O)botl.1:     $(PCH1) $(SRC)\botl.c     $(HACK_H)
$(O)cmd.1:      $(PCH1) $(SRC)\cmd.c      $(HACK_H) $(FUNC_TAB_H)
$(O)dbridge.1:  $(PCH1) $(SRC)\dbridge.c  $(HACK_H)
$(O)do.1:       $(PCH1) $(SRC)\do.c       $(HACK_H)
$(O)do_wear.1:  $(PCH1) $(SRC)\do_wear.c  $(HACK_H)
$(O)dog.1:      $(PCH1) $(SRC)\dog.c      $(HACK_H)
$(O)dungeon.1:	$(PCH1) $(SRC)\dungeon.c  $(HACK_H) $(ALIGN_H) $(DGN_FILE_H) $(DLB_H)
$(O)eat.1:      $(PCH1) $(SRC)\eat.c      $(HACK_H)
$(O)engrave.1:  $(PCH1) $(SRC)\engrave.c  $(HACK_H)
$(O)explode.1:  $(PCH1) $(SRC)\explode.c  $(HACK_H)
$(O)hack.1:     $(PCH1) $(SRC)\hack.c     $(HACK_H)
$(O)hacklib.1:  $(PCH1) $(SRC)\hacklib.c  $(HACK_H)
$(O)invent.1:   $(PCH1) $(SRC)\invent.c   $(HACK_H) $(ARTIFACT_H)
$(O)makemon.1:  $(PCH1) $(SRC)\makemon.c  $(HACK_H)
$(O)mhitu.1:    $(PCH1) $(SRC)\mhitu.c    $(HACK_H) $(ARTIFACT_H)
$(O)mkobj.1:    $(PCH1) $(SRC)\mkobj.c    $(HACK_H) $(ARTIFACT_H) $(PROP_H)
$(O)mon.1:      $(PCH1) $(SRC)\mon.c      $(HACK_H) $(MFNDPOS_H)
$(O)mondata.1:  $(PCH1) $(SRC)\mondata.c  $(HACK_H)
$(O)monmove.1:  $(PCH1) $(SRC)\monmove.c  $(HACK_H) $(MFNDPOS_H) $(ARTIFACT_H)
$(O)mthrowu.1:  $(PCH1) $(SRC)\mthrowu.c  $(HACK_H)
$(O)objnam.1:   $(PCH1) $(SRC)\objnam.c   $(HACK_H)
$(O)polyself.1: $(PCH1) $(SRC)\polyself.c $(HACK_H)
$(O)rnd.1:      $(PCH1) $(SRC)\rnd.c      $(HACK_H)
$(O)shk.1:      $(PCH1) $(SRC)\shk.c      $(HACK_H)
$(O)steal.1:    $(PCH1) $(SRC)\steal.c    $(HACK_H)
$(O)timeout.1:	$(PCH1) $(SRC)\timeout.c  $(HACK_H)
$(O)track.1:    $(PCH1) $(SRC)\track.c    $(HACK_H)
$(O)trap.1:     $(PCH1) $(SRC)\trap.c     $(HACK_H)
$(O)weapon.1:   $(PCH1) $(SRC)\weapon.c   $(HACK_H)
$(O)zap.1:      $(PCH1) $(SRC)\zap.c      $(HACK_H)

#
# OVL2
#

$(O)attrib.2:   $(PCH2) $(SRC)\attrib.c   $(HACK_H)
$(O)do.2:       $(PCH2) $(SRC)\do.c       $(HACK_H)
$(O)do_name.2:  $(PCH2) $(SRC)\do_name.c  $(HACK_H)
$(O)do_wear.2:  $(PCH2) $(SRC)\do_wear.c  $(HACK_H)
$(O)dog.2:      $(PCH2) $(SRC)\dog.c      $(HACK_H)
$(O)engrave.2:  $(PCH2) $(SRC)\engrave.c  $(HACK_H)
$(O)hack.2:     $(PCH2) $(SRC)\hack.c     $(HACK_H)
$(O)hacklib.2:  $(PCH2) $(SRC)\hacklib.c  $(HACK_H)
$(O)invent.2:   $(PCH2) $(SRC)\invent.c   $(HACK_H) $(ARTIFACT_H)
$(O)makemon.2:  $(PCH2) $(SRC)\makemon.c  $(HACK_H)
$(O)mon.2:      $(PCH2) $(SRC)\mon.c      $(HACK_H) $(MFNDPOS_H)
$(O)mondata.2:  $(PCH2) $(SRC)\mondata.c  $(HACK_H)
$(O)monmove.2:  $(PCH2) $(SRC)\monmove.c  $(HACK_H) $(MFNDPOS_H) $(ARTIFACT_H)
$(O)shk.2:      $(PCH2) $(SRC)\shk.c      $(HACK_H)
$(O)trap.2:     $(PCH2) $(SRC)\trap.c     $(HACK_H)
$(O)zap.2:      $(PCH2) $(SRC)\zap.c      $(HACK_H)

#
# OVL3
#

$(O)do.3:       $(PCH3) $(SRC)\do.c       $(HACK_H)
$(O)hack.3:     $(PCH3) $(SRC)\hack.c     $(HACK_H)
$(O)invent.3:	$(PCH3) $(SRC)\invent.c   $(HACK_H) $(ARTIFACT_H)
$(O)light.3:	$(PCH3) $(SRC)\light.c	  $(HACK_H)
$(O)shk.3:      $(PCH3) $(SRC)\shk.c      $(HACK_H)
$(O)trap.3:     $(PCH3) $(SRC)\trap.c     $(HACK_H)
$(O)zap.3:      $(PCH3) $(SRC)\zap.c      $(HACK_H)

#
# OVLB
#

$(O)allmain.B:  $(PCHB) $(SRC)\allmain.c  $(HACK_H)
$(O)apply.B:    $(PCHB) $(SRC)\apply.c    $(HACK_H)
$(O)artifact.B: $(PCHB) $(SRC)\artifact.c $(HACK_H) $(ARTIFACT_H) $(ARTILIST_H)
$(O)attrib.B:   $(PCHB) $(SRC)\attrib.c   $(HACK_H)
$(O)botl.B:     $(PCHB) $(SRC)\botl.c     $(HACK_H)
$(O)cmd.B:      $(PCHB) $(SRC)\cmd.c      $(HACK_H) $(FUNC_TAB_H)
$(O)dbridge.B:  $(PCHB) $(SRC)\dbridge.c  $(HACK_H)
$(O)do.B:       $(PCHB) $(SRC)\do.c       $(HACK_H)
$(O)do_name.B:  $(PCHB) $(SRC)\do_name.c  $(HACK_H)
$(O)do_wear.B:  $(PCHB) $(SRC)\do_wear.c  $(HACK_H)
$(O)dog.B:      $(PCHB) $(SRC)\dog.c      $(HACK_H)
$(O)dogmove.B:  $(PCHB) $(SRC)\dogmove.c  $(HACK_H) $(MFNDPOS_H)
$(O)eat.B:      $(PCHB) $(SRC)\eat.c      $(HACK_H)
$(O)engrave.B:  $(PCHB) $(SRC)\engrave.c  $(HACK_H)
$(O)hack.B:     $(PCHB) $(SRC)\hack.c     $(HACK_H)
$(O)hacklib.B:  $(PCHB) $(SRC)\hacklib.c  $(HACK_H)
$(O)invent.B:   $(PCHB) $(SRC)\invent.c   $(HACK_H) $(ARTIFACT_H)
$(O)lock.B:     $(PCHB) $(SRC)\lock.c     $(HACK_H)
$(O)mail.B:     $(PCHB) $(SRC)\mail.c     $(HACK_H) $(MAIL_H) $(DATE_H)
$(O)makemon.B:  $(PCHB) $(SRC)\makemon.c  $(HACK_H)
$(O)mcastu.B:   $(PCHB) $(SRC)\mcastu.c   $(HACK_H)
$(O)mhitm.B:    $(PCHB) $(SRC)\mhitm.c    $(HACK_H) $(ARTIFACT_H)
$(O)mhitu.B:    $(PCHB) $(SRC)\mhitu.c    $(HACK_H) $(ARTIFACT_H)
$(O)mkobj.B:    $(PCHB) $(SRC)\mkobj.c    $(HACK_H) $(ARTIFACT_H) $(PROP_H)
$(O)mkroom.B:   $(PCHB) $(SRC)\mkroom.c   $(HACK_H)
$(O)mon.B:      $(PCHB) $(SRC)\mon.c      $(HACK_H) $(MFNDPOS_H)
$(O)mondata.B:  $(PCHB) $(SRC)\mondata.c  $(HACK_H)
$(O)monmove.B:  $(PCHB) $(SRC)\monmove.c  $(HACK_H) $(MFNDPOS_H) $(ARTIFACT_H)
$(O)mthrowu.B:  $(PCHB) $(SRC)\mthrowu.c  $(HACK_H)
$(O)objnam.B:   $(PCHB) $(SRC)\objnam.c   $(HACK_H)
$(O)pline.B:    $(SRC)\pline.c    $(HACK_H)
	@type schema$(SCHEMA).bc | find "$(@B)_b" > $(VROOMMCFG)
	@echo $(BCOPTS1) >> $(VROOMMCFG)
	@echo $(BCOPTS2) >> $(VROOMMCFG)
	$(CC) $(CFLAGSN) $(COBJNAM)$@ $(SRC)\pline.c
$(O)polyself.B: $(PCHB) $(SRC)\polyself.c $(HACK_H)
$(O)potion.B:   $(PCHB) $(SRC)\potion.c   $(HACK_H)
$(O)priest.B:   $(PCHB) $(SRC)\priest.c   $(HACK_H) $(MFNDPOS_H)
$(O)read.B:     $(PCHB) $(SRC)\read.c     $(HACK_H)
$(O)rnd.B:      $(PCHB) $(SRC)\rnd.c      $(HACK_H)
$(O)shk.B:      $(PCHB) $(SRC)\shk.c      $(HACK_H)
$(O)shknam.B:   $(PCHB) $(SRC)\shknam.c   $(HACK_H)
$(O)sounds.B:   $(PCHB) $(SRC)\sounds.c   $(HACK_H)
$(O)steal.B:    $(PCHB) $(SRC)\steal.c    $(HACK_H)
$(O)timeout.B:	$(PCHB) $(SRC)\timeout.c  $(HACK_H)
$(O)track.B:    $(PCHB) $(SRC)\track.c    $(HACK_H)
$(O)trap.B:     $(PCHB) $(SRC)\trap.c     $(HACK_H)
$(O)vault.B:    $(PCHB) $(SRC)\vault.c    $(HACK_H)
$(O)weapon.B:   $(PCHB) $(SRC)\weapon.c   $(HACK_H)
$(O)were.B:     $(PCHB) $(SRC)\were.c     $(HACK_H)
$(O)wizard.B:   $(PCHB) $(SRC)\wizard.c   $(HACK_H)
$(O)zap.B:      $(PCHB) $(SRC)\zap.c      $(HACK_H)

# end of file
